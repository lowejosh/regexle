const t="expert-002",e="Nested Parentheses Zen Master",s="Identify grouping symbols that maintain perfect structural harmony. Each opening symbol must have a corresponding closing partner, and they must be arranged in proper hierarchical order without crossing boundaries.",n="expert",a=[{input:"()",shouldMatch:!0},{input:"(())",shouldMatch:!0},{input:"((()))",shouldMatch:!0},{input:"()()",shouldMatch:!0},{input:"(()())",shouldMatch:!0},{input:"(()(()))",shouldMatch:!0},{input:"(",shouldMatch:!1},{input:")",shouldMatch:!1},{input:"(()",shouldMatch:!1},{input:"())",shouldMatch:!1},{input:")((",shouldMatch:!1},{input:"((())()))",shouldMatch:!1}],r="^(?:\\((?:[^()]|\\((?:[^()]|\\([^()]*\\))*\\))*\\))+$",h="This pattern matches balanced parentheses by using nested structure recognition. The outer (?:...)+allows multiple parentheses groups, while the inner pattern recursively handles nesting: [^()] matches non-parentheses characters, and \\((?:[^()]|\\([^()]*\\))*\\) matches a parentheses group that can contain either non-parentheses characters or another level of nested parentheses.",o={id:t,title:e,description:s,difficulty:n,testCases:a,solution:r,solutionSummary:h};export{o as default,s as description,n as difficulty,t as id,r as solution,h as solutionSummary,a as testCases,e as title};
